---
title: "Zen of Nim"
author: "Andreas Rumpf (Araq)"
excerpt: "transcript of Zen of Nim presentation at NimConf2021"
---

<div class="sidebarblock">
  <div class="content">
    <div class="paragraph">
      This is a transcript of Araq's presentation at NimConf2021 delivered on June 26th
      (see the video on <a href="https://www.youtube.com/watch?v=D_G9h7DcIqM">youtube</a>, check the source on <a href="https://github.com/Araq/nimconf2021">github</a>).
      It has been adapted to blog post format by <a href="https://github.com/pietroppeter">Pietro Peterlongo</a>.
    </div>
  </div>
</div>
<!-- github repo should have pages active as in https://pietroppeter.github.io/nimconf2021-1/htmldocs/zennim.html-->

# Zen of Nim

<!--it makes sense to have the final set of rules explicit as first thing-->

1. Copying bad design is not good design.
2. If the compiler cannot reason about the code, neither can the programmer.
3. Don't get in the programmer's way.
4. Move work to compile-time: Programs are run more often than they are compiled.
5. Customizable memory management.
6. Concise code is not in conflict with readability, it enables readability.
7. (Leverage meta programming to keep the language small.)
8. Optimization is specialization: When you need more speed, write custom code.
9. There should be one and only one programming language for everything. That language is Nim.

# Introduction

In this blog post I will explain the philosophy of Nim language and why Nim can be useful for a wide range of application domains, such as:

- scientific computing
- games
- compilers
- operating systems development
- scripting
- everything else

<!-- could be nice to add links to other nim conf talks related to these domains-->

"Zen" means that we will arrive at a set of rules (shown above) that guide the language design and evolution, but I will go through these rules via examples.

# Syntax

Nim has an **indentation based syntax** as inspired by Haskell or Python that **fits Nim's macro system**.


## Function application

Function application is `f()`, `f(a)`, `f(a, b)`.

And here is the sugar:

|   |  Sugar     |   Meaning           |   Example                      |
|---|------------|---------------------|--------------------------------|
| 1 |  `f a`     |   `f(a)`            |   `spawn log("some message")`  |
| 2 |  `f a, b`  |   `f(a, b)`         |   `echo "hello ", "world"`     |
| 3 |  `a.f()`   |   `f(a)`            |   `db.fetchRow()`              |
| 4 |  `a.f`     |   `f(a)`            |   `mystring.len`               |
| 5 |  `a.f(b)`  |   `f(a, b)`         |   `myarray.map(f)`             |
| 6 |  `a.f b`   |   `f(a, b)`         |   `db.fetchRow 1`              |
| 7 |  `f"\n"`   |   `f(r"\n")`        |   `re"\b[a-z*]\b"`             |
| 8 |  `f a: b`  |   `f(a, b)`         |   `lock x: echo "hi"`          |


**BUT**: `f` does not mean `f()`; `myarray.map(f)` passes `f` to `map`


## Operators

* Most of the time binary operators are simply invoked as `x @ y`
  and unary operators as `@x`.
* No explicit distinction between binary and unary operators:

```nim
func `++`(x: var int; y: int = 1; z: int = 0) =
  x = x + y + z

var g = 70
++g
g ++ 7
# operator in backticks is treated like an 'f':
g.`++`(10, 20)
echo g  # writes 108
```

* operators are simply sugar for functions
* parameters are readonly unless declared as `var`
* `var` means "pass by reference" (implemented with a hidden pointer)


## Statements vs expressions

Statements require indentation:

```nim
# no indentation needed for single assignment statement:
if x: x = false

# indentation needed for nested if statement:
if x:
  if y:
    y = false
else:
  y = true

# indentation needed, because two statements
# follow the condition:
if x:
  x = false
  y = false
```
<!-- you can also use semi columns -->

Expressions do not:

```nim
if thisIsaLongCondition() and
    thisIsAnotherLongCondition(1,
        2, 3, 4):
  x = true
```

- Rule of thumb: optional indentation after operators, `(` and `,`
- `if`, `case` etc also available as expressions

As a simple example to conclude this section about syntax,
here is a function that finds the first occurrence in string
of one out of a set of characters.

```nim
func indexOf(s: string; x: set[char]): int =
  for i in 0..<s.len:
    if s[i] in x: return i
  return -1

let whitespacePos = indexOf("abc def", {' ', '\t'})
echo whitespacePos
```

# Zen of Nim

## 6. Concise code is not in conflict with readability, it enables readability.

<!-- discussion about nim's syntax -->

## 2. Compiler must be able to reason about the code

- Structured programming.
- Static typing!
- Static binding!
- Side effects tracking.
- Exception tracking.
- Mutability restrictions.
- Value based datatypes. (Aliasing is very hard to reason about!)


### Structured programming

```nim
import tables, strutils

proc countWords(filename: string): CountTable[string] =
  ## Counts all the words in the file.
  result = initCountTable[string]()
  for word in readFile(filename).split:
    result.inc word
  # 'result' instead of 'return', no unstructed control flow
```

<!-- nim offers the return statement but we advise you not to use it, since that is unstructured programming

structured programming means you have a single entry point and exit point in the code.
-->


```nim
for item in collection:
  if item.isBad: continue
  # what do we know here at this point?
  use item
```

<!--
compare with the following. you can use continue but it is not advised
more importantly it means we will never add a more general goto statement 
-->

```nim
for item in collection:
  if not item.isBad:
    # what do we know here at this point?
    # that the item is not bad.
    use item
```

<!-- we want to be in a position to prove more and more stuff about your code
and structured programming make it easier-->

### Static typing

distinct & enums & sets

<!-- we really want you to use custom types adapted to the problem domain-->

```nim
type
  SandboxFlag = enum         ## what the interpreter should allow
    allowCast,               ## allow unsafe language feature: 'cast'
    allowFFI,                ## allow the FFI
    allowInfiniteLoops       ## allow endless loops

  NimCode = distinct string

proc runNimCode(code: NimCode; flags: set[SandboxFlag] = {allowCast, allowFFI}) =
  ...
```
<!--
if you compare with the C example you lose the type safety

and you lose information on what are valid values and the compiler cannot help
-->

```c
#define allowCast (1 << 0)
#define allowFFI (1 << 1)
#define allowInfiniteLoops (1 << 2)

void runNimCode(char* code, unsigned int flags = allowCast|allowFFI);

runNimCode("4+5", 700); // nobody stops us from passing 700
```

### Static binding

<!---->

```nim
echo "hello ", "world", 99
```

is rewritten to:

```nim
echo([$"hello ", $"world", $99])
```

- echo is declared as: ``proc echo(a: varargs[string, `$`]);``
- `$` (Nim's `toString` operator) is applied to every argument
- overloading instead of dynamic binding


- it is extensible:

```nim
proc `$`(x: MyObject): string = x.s
var obj = MyObject(s: "xyz")
echo obj  # works
```

### Value based datatypes

<!-- wrt to functional languages you want to restrict aliasing instead of mutation
because mutation is efficient-->

```nim
type
  Rect = object
    x, y, w, h: int

# construction:
let r = Rect(x: 12, y: 22, w: 40, h: 80)

# field access:
echo r.x, " ", r.y

# assignment does copy:
var other = r
other.x = 10
assert r.x == 12
```

<!-- no spooky action at a distance -->

### Side effects tracking

```nim
import strutils

proc count(s: string, sub: string): int {.noSideEffect.} =
  result = 0
  var i = 0
  while true:
    i = s.find(sub, i)
    if i < 0: break
    echo "i is: ", i  # error: 'echo' can have side effects
    i += sub.len
    inc result
```

<!-- the compiler is smart and helps you, but sometimes you need to override-->

```nim
import strutils

proc count(s: string, sub: string): int {.noSideEffect.} =
  result = 0
  var i = 0
  while true:
    i = s.find(sub, i)
    if i < 0: break
    {.cast(noSideEffect).}:
      echo "i is: ", i  # 'cast', so go ahead
    i += sub.len
    inc result
```

<!--cast means: I know what I am doing-->

### Exception tracking

```nim
import os

proc main() {.raises: [].} =
  copyDir("from", "to")
  # Error: copyDir("from", "to") can raise an
  # unlisted exception: ref OSError
```

```nim
import os

proc main() {.raises: [OSError].} =
  copyDir("from", "to")
  # compiles :-)
```

<!--
I was really surprised that this worked out of the box (probably beacuse somebody else helped me out and fix this bug)
-->

```nim
proc x[E]() {.raises: [E].} =
  raise newException(E, "text here")

try:
  x[ValueError]()
except ValueError:
  echo "good"
```

### Mutability restrictions

```nim
{.experimental: "strictFuncs".}

type
  Node = ref object
    next, prev: Node
    data: string

func len(n: Node): int =
  var it = n
  result = 0
  while it != nil:
    inc result
    it = it.next
```

<!--
crucial part is that with strictFuncs we ...
-->

```nim
{.experimental: "strictFuncs".}

func insert(x: var seq[Node]; y: Node) =
  let L = x.len
  x.setLen L + 1
  x[L] = y


func doesCompile(n: Node) =
  var m = Node()
  m.data = "abc"
```

<!-- semantics: you cannot mutate  -->

```nim
{.experimental: "strictFuncs".}

func doesNotCompile(n: Node) =
  n.data = "abc"
```

<!-- we can try to trick the compiler -->

```nim
{.experimental: "strictFuncs".}

func select(a, b: Node): Node = b

func mutate(n: Node) =
  var it = n
  let x = it
  let y = x
  let z = y # <-- is the statement that connected
            # the mutation to the parameter

  select(x, z).data = "tricky" # <-- the mutation is here
  # Error: an object reachable from 'n'
  # is potentially mutated
```

<!-- what it does internally, it has a notion of a graph, ... 


this all is summarized in:
-->


<center><big><big><big><big>If the compiler cannot reason about the code,
neither can the programmer.</big></big></big></big></center>



## 1. Copying bad design is not good design

Bad: Language X has feature F, let's have that too!

("C++ has compile-time function evaluation, let's have that too!")

Good: We have many use cases for feature F.

<!-- in this case F is macro system -->

> ("We need to be able to do locking, logging, lazy evaluation,
> a typesafe Writeln/Printf, a declarative UI description language,
> async and parallel programming! So instead of building these
> features into the language, let's have a macro system.")


### Meta programming features

Templates for lazy evaluation:

```nim
template log(msg: string) =
  if debug:
    echo msg

log("x: " & $x & ", y: " & $y)
```

Roughly comparable to:

```c
#define log(msg) \
  if (debug) { \
    print(msg); \
  }

log("x: " + x.toString() + ", y: " + y.toString());
```

<!-- usual would be to evaluate an expression and call the function -->

Templates for control flow abstraction:

<!-- in C# it is a language primitive, in nim you implement it with a template -->

```nim
template withLock(lock, body) =
  var lock: Lock
  try:
    acquire lock
    body
  finally:
    release lock

withLock myLock:
  accessProtectedResource()
```

Macros to implement DSLs:

```nim
html mainPage:
  head:
    title "Zen of Nim"
  body:
    ul:
      li "A bunch of rules that make no sense."

echo mainPage()
```

Produces::

```html
<html>
  <head><title>Zen of Nim</title></head>
  <body>
    <ul>
      <li>A bunch of rules that make no sense.</li>
    </ul>
  </body>
</html>
```


#### Lifting

```nim
import math

template liftFromScalar(fname) =
  proc fname[T](x: openArray[T]): seq[T] =
    result = newSeq[typeof(x[0])](x.len)
    for i in 0..<x.len:
      result[i] = fname(x[i])

# make sqrt() work for sequences:
liftFromScalar(sqrt)
echo sqrt(@[4.0, 16.0, 25.0, 36.0])
# => @[2.0, 4.0, 5.0, 6.0]
```


#### Declarative programming

<!-- you can use templates to turn imperative into declarative programming -->

```nim
proc threadTests(r: var Results, cat: Category,
                  options: string) =
  template test(filename: untyped) =
    testSpec r, makeTest("tests/threads" / filename,
      options, cat, actionRun)
    testSpec r, makeTest("tests/threads" / filename,
      options & " -d:release", cat, actionRun)
    testSpec r, makeTest("tests/threads" / filename,
      options & " --tlsEmulation:on", cat, actionRun)

  test "tactors"
  test "tactors2"
  test "threadex"
```

#### Varargs

```nim
test "tactors"
test "tactors2"
test "threadex"
```

```nim
test "tactors", "tactors2", "threadex"
```

```nim
import macros

macro apply(caller: untyped;
            args: varargs[untyped]): untyped =
  result = newStmtList()
  for a in args:
    result.add(newCall(caller, a))

apply test, "tactors", "tactors2", "threadex"
```

<!-- details are not important and ... -->

#### Typesafe Writeln/Printf

```nim
proc write(f: File; a: int) = echo a
proc write(f: File; a: bool) = echo a
proc write(f: File; a: float) = echo a

proc writeNewline(f: File) =
  echo "\n"

macro writeln*(f: File; args: varargs[typed]) =
  result = newStmtList()
  for a in args:
    result.add newCall(bindSym"write", f, a)
  result.add newCall(bindSym"writeNewline", f)
```

## 3. Don't get in the programmer's way

<!-- yes, the compiler is smart but don't get in the programmer's way -->

- Interoperability with C++, C and JavaScript.
- By compiling Nim to these languages.
- Low level features are available:

  * Bit twiddling
  * unsafe type conversions ("cast")
  * raw pointers.

<!--
the philosophy is not let's use C++ and Nim because Nim does have a particular feature
interfacing with C++ is last resort but then real world kicks in

ideally you only use nim language
-->

### Emit pragma

<!-- the interoperability story goes so far that we  -->

```nim
{.emit: """
static int cvariable = 420;
""".}

proc embedsC() =
  var nimVar = 89
  {.emit: ["""fprintf(stdout, "%d\n", cvariable + (int)""",
    nimVar, ");"].}

embedsC()
```

<!--
we want you to be able to get things done
we want the language to be practical
-->


<!-- transtion to talk about memory management, still under don't get in programmer way? no!-->

## 5. Customizable memory management

### Sink parameters

<!-- destructor and ownerships are hopefully familiar from C++ and Rust -->

```nim
func f(x: sink string) =
  discard "do nothing"

f "abc"
```

Compile with `nim c --gc:orc --expandArc:f $file`

<!-- did I produce a memory leak? show me ... -->

```nim
func f(x: sink string) =
  discard "do nothing"
  `=destroy`(x)
```

**Nim's intermediate language is Nim itself.**

a different example:

```nim
var g: string

proc f(x: sink string) =
  g = x

f "abc"
```

we ask the compiler what does it do:

```nim
var g: string

proc f(x: sink string) =
  `=sink`(g, x)

f "abc"
```

<!-- x was moved into g and then it was destructed but compiler optimized -->

```nim
var g: string

proc f(x: sink string) =
  `=sink`(g, x)
  # optimized out:
  wasMoved(x)
  `=destroy`(x)

f "abc"
```

Destructors

```nim
type
  myseq*[T] = object
    len, cap: int
    data: ptr UncheckedArray[T]

proc `=destroy`*[T](x: var myseq[T]) =
  if x.data != nil:
    for i in 0..<x.len: `=destroy`(x[i])
    dealloc(x.data)
```

Move operator

```nim
proc `=sink`*[T](a: var myseq[T]; b: myseq[T]) =
  # move assignment, optional.
  # Compiler is using `=destroy` and
  # `copyMem` when not provided
  `=destroy`(a)
  a.len = b.len
  a.cap = b.cap
  a.data = b.data
```

Assignment operator

```nim
proc `=copy`*[T](a: var myseq[T]; b: myseq[T]) =
  # do nothing for self-assignments:
  if a.data == b.data: return
  `=destroy`(a)
  a.len = b.len
  a.cap = b.cap
  if b.data != nil:
    a.data = cast[typeof(a.data)](
      alloc(a.cap * sizeof(T)))
    for i in 0..<a.len:
      a.data[i] = b.data[i]
```

<!-- this accessors part is not discussed during presentation -->
Accessors

```nim
proc add*[T](x: var myseq[T]; y: sink T) =
  if x.len >= x.cap: resize(x)
  x.data[x.len] = y
  inc x.len

proc `[]`*[T](x: myseq[T]; i: Natural): lent T =
  assert i < x.len
  x.data[i]

proc `[]=`*[T](x: var myseq[T]; i: Natural; y: sink T) =
  assert i < x.len
  x.data[i] = y
```

Customizable memory management

# Zen of Nim

- Copying bad design is not good design.
- If the compiler cannot reason about the code, neither can the programmer.
- Don't get in the programmer's way.
- Move work to compile-time: Programs are run more often than they are compiled.
- Customizable memory management.
- Concise code is not in conflict with readability, it enables readability.
- (Leverage meta programming to keep the language small.)
- Optimization is specialization: When you need more speed, write custom code.
- There should be one and only one programming language for everything. That language is Nim.

<!-- there is friction between we want the language to be complete vs we want

optimization is specialization: was not covered before. when you need more speed.
-->
